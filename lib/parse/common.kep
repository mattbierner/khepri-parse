/**
 * @fileOverview 
 */
package (
    sepEndWith1
    sepEndWith
    sepEndWith0
        
    precedence
    node
    nodea
    positionParser)
with
    import 'bennu::parse' parse#{
        always
        bind
        binds
        cons
        either
        enumeration
        extract
        eager
        optional
        next
        rec},
    import 'nu-stream::stream' stream#{NIL},

    import 'khepri-ast::position' {SourceLocation}
in {

/* Parser Combinators
 ******************************************************************************/
sepEndWith1 := \sep end p ->
    rec\self ->
        cons(
            p,
            optional(NIL,
                next(sep,
                    either(enumeration(end), self))));

sepEndWith := \sep end p ->
    either(
        enumeration(end),
        sepEndWith1(sep, end, p));

sepEndWith0 := sepEndWith \>> optional@NIL;

/* 
 ******************************************************************************/
var SepData := function \value metadata =self-> {
    self.value = value;
    self.metadata = metadata;
};

var pres := \list -> {
    var stack = [],
        out = [];
    
    while (list.length > 0) {
        var tok = list.shift();
        if (tok instanceof SepData) {
            while (stack.length > 0)
            with
                o2 = stack.(stack.length - 1)
            in {
                if ((!tok.metadata.right && o2.metadata.precedence === tok.metadata.precedence) ||
                  (o2.metadata.precedence < tok.metadata.precedence)) {
                    stack.pop();
                    with
                        rt = out.pop(),
                        lf = out.pop()
                    in {
                        out.push(
                            o2.metadata.node(
                                SourceLocation.merge(lf.loc, rt.loc),
                                o2.value,
                                lf,
                                rt));
                    }
                } else {
                    break;
                }
            }
            stack.push(tok);
        } else {
            out.push(tok);
        }
    }
    
    while (stack.length > 0)
    with
        o = stack.pop(),
        rt = out.pop(),
        lf = out.pop()
    in {
        out.push(
            o.metadata.node(
                SourceLocation.merge(lf.loc, rt.loc),
                o.value,
                lf,
                rt));
    }
    return out.pop();
};

// Operator Precedence
////////////////////////////////////////
precedence = \first p table -> let
    sep =
        parse.choice <<|
            table.map \ entry ->
                entry.sep.map \ value ->
                    new SepData(value, entry)
in
    eager(
        cons(first,
            optional(NIL,
                cons(sep,
                    parse.expected("binary expression",
                        rec \ self ->
                            parse.cons(p,
                                optional(NIL,
                                    parse.cons(sep,
                                        parse.expected("binary expression", self)))))))))
            .map(pres);

// State Interaction
////////////////////////////////////////
positionParser := extract (.position.sourcePosition);

var prevEnd := extract (.position.prevEnd);

var loc := \p ->
    enumeration(
        positionParser,
        p,
        prevEnd);

// Ast Node
////////////////////////////////////////
/**
 * Helper function that parses `p` and its location, calling `f` with loc and
 * result of `p`.
 */
node := \p f ->
    binds(
        loc p,
        \o x c ->
            always <| f(new SourceLocation(o, c), x));

/**
 * Helper function that parses stream parser `p` and its location, calling
 * `f` with loc and results of `p`.
 */
nodea := \p f ->
    node(p, \loc x ->
        f <<| stream.toArray(stream.cons(loc, x)));

}